package Homework.Java2.SwinefordHW1;
import java.util.Random;
import java.util.Scanner;

/**
 * Allows the user to play the game of Lights Out.
 * The user specifies a grid size, which initializes a
 * new grid using random moves generated by the computer
 * (gridSize^2). This is the main means of shuffling the
 * board while confirming the the grid generated is possible
 * to solve.
 *
 * "#" = on
 * "." = off
 *
 * Afterwords, the game functions as follows:
 *
 * 1. The user specifies a row and a column,
 * which pinpoints a point on the grid.
 *
 * 2. the point and it's adjacent points are
 * flipped, where "." turns into "#" and "#'
 * turns into ".".
 *
 * 3. a new grid will be created based on the player's
 * move, and this process will continue until either
 * all the lights are off or all the lights are on.
 * At that time, the application will stop and show
 * the winning message.
 *
 * DISCLAIMER: I modified the problem to be able to
 * precisely display grids bigger than 10. This is done by
 * implementing spaces based on the number of digits from
 * o.length, and duplicating the "." and "#" to fit the new
 * length demanding by multiple digits. There are also cases
 * for grid size <= 1.
 *
 * I also added the feature of winning by having all the
 * lights on. Though harder, I have been able to manage
 * this during testing.
 *
 * @author Jacob Swineford
 */
public class LightsOut {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print("Enter grid size (1 - Any positive value): ");
        int gS = in.nextInt();

        if (gS <= 0) {
            System.out.println("\nNot Valid." +
                    " Grid size must be 1 or higher.");
        } else if (gS == 1) {
            System.out.print("\nThe initial moves will" +
                    " determine the outcome.\n" +
                    "Enter initial moves: ");
            int i = in.nextInt();
            if (i % 2 == 0) {
                System.out.println("\n  0");
                System.out.println("0 .");
                System.out.println("\nLIGHTS OUT!");
            } else {
                System.out.println("\n  0");
                System.out.println("0 #");
                System.out.println("\nLIGHTS ON!");
            }
        } else {
            boolean[][] o = new boolean[gS][gS];
            boolean z = true;
            dIGrid(o, z);
            z = false;
            int co = 1;

            while(!lightsOut(o) && !lightsOn(o)) {
                System.out.println();
                System.out.print(co + "." + " Enter your move (row-col): ");
                int a = in.nextInt();
                int b = in.nextInt();
                simulateMove(o, a, b);
                dIGrid(o, z);
                co++;
            }

            if (lightsOn(o)) {
                System.out.println("\nLIGHTS ON!");
            } else {
                System.out.println("\nLIGHTS OUT!");
            }
        }
    }

    /**
     * displays and initializes the grid using the given boolean
     * and int arguments.
     *
     * If boolean z is true, then the grid is initialized
     * using random moves, and displayed. else, this method
     * is only displays the grid for further use in the application.
     */
    private static void dIGrid(boolean[][] o, boolean z) {
        Random rand = new Random();
        System.out.println();
        String iSpaces = "  ";

        int eDigits = numDigits(o.length) - 1;
        for (int y = 0; y < eDigits; y++) {
            iSpaces += " ";
        }

        System.out.print(iSpaces + 0 + "  ");
        for (int k = 1; k < o.length; k++) {
            System.out.print(k + "  ");
        }
        System.out.println();

        if (z) {
            for (int p = 0; p < o.length * o.length; p++) {
                int r = rand.nextInt(o.length);
                int r2 = rand.nextInt(o.length);
                simulateMove(o, r, r2);
            }
        }
        DMiddleGrid(o);
    }

    /**
     * Displays the middle part of the grid for the game of lights out.
     * This includes the numbering on the side, as well as the periods and
     * hash-tags generated using the boolean[][].
     */
    private static void DMiddleGrid(boolean[][] o) {

        for (int i = 0; i < o.length; i++) {
            for (int k = 0; k < o.length; k++) {
                String d = "";
                String h = "";
                for (int j = 0; j < numDigits(k); j++) {
                    d += ".";
                    h += "#";
                }

                if (k == 0) {
                    String spaces = "";
                    int maxDig = numDigits(o.length - 1);
                    while (maxDig != numDigits(i)) {
                        spaces += " ";
                        maxDig--;
                    }
                    System.out.print(spaces + i);
                }

                if (!o[i][k]) {
                    System.out.print(" " + d + " ");
                } else if (o[i][k]) {
                    System.out.print(" " + h + " ");
                }
            }
            System.out.println();
        }
    }

    /**
     * Simulates any move the is given as player input.
     * if the move is illegal, then the input will be ignored.
     *
     * NOTE: There are 9 different ways that the boolean values
     * can be systematically changed. These include the four corners,
     * the four sides, and the middle. The first 8 represent values
     * obtained while on the edge. every other value that can be inputted
     * will belong to the middle.
     */
    private static void simulateMove(boolean[][] o, int a, int b) {
        if (a < 0 || a > o.length - 1 || b < 0 || b > o.length - 1) {
            System.out.print("Invalid input. Try again.");
            System.out.println();
            return;
        }

        if (a == 0 && b != 0 && b != o.length - 1) {
            setOpposite(o, a, b);
            setOpposite(o, a + 1, b);
            setOpposite(o, a, b + 1);
            setOpposite(o, a, b - 1);
        } else if (a == o.length - 1 && b != 0 && b != o.length - 1) {
            setOpposite(o, a, b);
            setOpposite(o, a - 1, b);
            setOpposite(o, a, b + 1);
            setOpposite(o, a, b - 1);
        } else if (b == 0 && a != 0 && a != o.length - 1) {
            setOpposite(o, a, b);
            setOpposite(o, a + 1, b);
            setOpposite(o, a, b + 1);
            setOpposite(o, a - 1, b);
        } else if (b == o.length - 1 && a != 0 && a != o.length - 1) {
            setOpposite(o, a, b);
            setOpposite(o, a + 1, b);
            setOpposite(o, a, b - 1);
            setOpposite(o, a - 1, b);
        } else if (a == 0 && b == a) {
            setOpposite(o, a, b);
            setOpposite(o, a + 1, b);
            setOpposite(o, a, b + 1);
        } else if (a == 0 && b == o.length - 1) {
            setOpposite(o, a, b);
            setOpposite(o, a + 1, b);
            setOpposite(o, a, b - 1);
        } else if (a == o.length - 1 && b == a) {
            setOpposite(o, a, b);
            setOpposite(o, a, b - 1);
            setOpposite(o, a - 1, b);
        } else if (a == o.length - 1 && b == 0) {
            setOpposite(o, a, b);
            setOpposite(o, a - 1, b);
            setOpposite(o, a, b + 1);
        } else {
            setOpposite(o, a, b);
            setOpposite(o, a + 1, b);
            setOpposite(o, a - 1, b);
            setOpposite(o, a, b + 1);
            setOpposite(o, a, b - 1);
        }
    }

    /**
     * Makes the boolean value at a, b the opposite of
     * it's current value within the given boolean[][].
     */
    private static void setOpposite(boolean[][] o, int a, int b) {
        if (!o[a][b]) {
            o[a][b] = true;
        } else {
            o[a][b] = false;
        }
    }

    /**
     * checks if the given boolean[][]'s values are all false or not.
     * if so, this method returns true. otherwise, false.
     */
    private static boolean lightsOut(boolean[][] o) {
        for (boolean[] bo : o) {
            for (boolean b : bo) {
                if (b) {
                  return false;
                }
            }
        }
        return true;
    }

    /**
     * checks if the given boolean[][]'s values are all true or not.
     * if so, this method returns true. otherwise, false.
     */
    private static boolean lightsOn(boolean[][] o) {
        for (boolean[] bo : o) {
            for (boolean b : bo) {
                if (!b) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Finds the number of digits of the given integer and
     * returns the count.
     */
    private static int numDigits(int in) {
        int b = Integer.toString(in).length();
        int count = 0;
        for (int i = 0; i < b; i++) {
            count++;
        }
        return count;
    }
}
